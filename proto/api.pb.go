// Code generated by protoc-gen-go. DO NOT EDIT.
// source: proto/api.proto

/*
Package client is a generated protocol buffer package.

It is generated from these files:
	proto/api.proto

It has these top-level messages:
	Block
	FileMeta
	Directory
	Volume
	HostStash
	OpenRequest
	GetBlockRequest
	GetBlockResponse
	AppendToBlockRequest
	DeleteBlockRequest
	WriteResult
	NewDirectoryContract
	AcquireFileWriteLockContract
	ReleaseFileWriteLockContract
	NewFileContract
	FileWriteLock
	Nothing
*/
package client

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Block struct {
	Hash  []byte   `protobuf:"bytes,2,opt,name=hash,proto3" json:"hash,omitempty"`
	Key   []byte   `protobuf:"bytes,3,opt,name=key,proto3" json:"key,omitempty"`
	Hosts []uint64 `protobuf:"varint,1,rep,packed,name=hosts" json:"hosts,omitempty"`
}

func (m *Block) Reset()                    { *m = Block{} }
func (m *Block) String() string            { return proto.CompactTextString(m) }
func (*Block) ProtoMessage()               {}
func (*Block) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Block) GetHash() []byte {
	if m != nil {
		return m.Hash
	}
	return nil
}

func (m *Block) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *Block) GetHosts() []uint64 {
	if m != nil {
		return m.Hosts
	}
	return nil
}

type FileMeta struct {
	Name          string   `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Size          uint64   `protobuf:"varint,2,opt,name=size" json:"size,omitempty"`
	Last_Modified uint64   `protobuf:"varint,3,opt,name=last_Modified,json=lastModified" json:"last_Modified,omitempty"`
	CreatedAt     uint64   `protobuf:"varint,4,opt,name=created_at,json=createdAt" json:"created_at,omitempty"`
	LockTime      uint64   `protobuf:"varint,5,opt,name=lock_time,json=lockTime" json:"lock_time,omitempty"`
	BlockSize     uint32   `protobuf:"varint,6,opt,name=block_size,json=blockSize" json:"block_size,omitempty"`
	Key           []byte   `protobuf:"bytes,7,opt,name=key,proto3" json:"key,omitempty"`
	Blocks        []*Block `protobuf:"bytes,8,rep,name=blocks" json:"blocks,omitempty"`
}

func (m *FileMeta) Reset()                    { *m = FileMeta{} }
func (m *FileMeta) String() string            { return proto.CompactTextString(m) }
func (*FileMeta) ProtoMessage()               {}
func (*FileMeta) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *FileMeta) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *FileMeta) GetSize() uint64 {
	if m != nil {
		return m.Size
	}
	return 0
}

func (m *FileMeta) GetLast_Modified() uint64 {
	if m != nil {
		return m.Last_Modified
	}
	return 0
}

func (m *FileMeta) GetCreatedAt() uint64 {
	if m != nil {
		return m.CreatedAt
	}
	return 0
}

func (m *FileMeta) GetLockTime() uint64 {
	if m != nil {
		return m.LockTime
	}
	return 0
}

func (m *FileMeta) GetBlockSize() uint32 {
	if m != nil {
		return m.BlockSize
	}
	return 0
}

func (m *FileMeta) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *FileMeta) GetBlocks() []*Block {
	if m != nil {
		return m.Blocks
	}
	return nil
}

type Directory struct {
	Name  string   `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Key   []byte   `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	Files [][]byte `protobuf:"bytes,3,rep,name=files,proto3" json:"files,omitempty"`
}

func (m *Directory) Reset()                    { *m = Directory{} }
func (m *Directory) String() string            { return proto.CompactTextString(m) }
func (*Directory) ProtoMessage()               {}
func (*Directory) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *Directory) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Directory) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *Directory) GetFiles() [][]byte {
	if m != nil {
		return m.Files
	}
	return nil
}

type Volume struct {
	Name         string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Key          []byte `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	Replications uint32 `protobuf:"varint,3,opt,name=replications" json:"replications,omitempty"`
	BlockSize    uint32 `protobuf:"varint,4,opt,name=block_size,json=blockSize" json:"block_size,omitempty"`
	RootDir      []byte `protobuf:"bytes,5,opt,name=root_dir,json=rootDir,proto3" json:"root_dir,omitempty"`
}

func (m *Volume) Reset()                    { *m = Volume{} }
func (m *Volume) String() string            { return proto.CompactTextString(m) }
func (*Volume) ProtoMessage()               {}
func (*Volume) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *Volume) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Volume) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *Volume) GetReplications() uint32 {
	if m != nil {
		return m.Replications
	}
	return 0
}

func (m *Volume) GetBlockSize() uint32 {
	if m != nil {
		return m.BlockSize
	}
	return 0
}

func (m *Volume) GetRootDir() []byte {
	if m != nil {
		return m.RootDir
	}
	return nil
}

type HostStash struct {
	HostId   uint64 `protobuf:"varint,1,opt,name=host_id,json=hostId" json:"host_id,omitempty"`
	Capacity uint64 `protobuf:"varint,2,opt,name=capacity" json:"capacity,omitempty"`
	Used     uint64 `protobuf:"varint,3,opt,name=used" json:"used,omitempty"`
	Owner    uint64 `protobuf:"varint,4,opt,name=owner" json:"owner,omitempty"`
}

func (m *HostStash) Reset()                    { *m = HostStash{} }
func (m *HostStash) String() string            { return proto.CompactTextString(m) }
func (*HostStash) ProtoMessage()               {}
func (*HostStash) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *HostStash) GetHostId() uint64 {
	if m != nil {
		return m.HostId
	}
	return 0
}

func (m *HostStash) GetCapacity() uint64 {
	if m != nil {
		return m.Capacity
	}
	return 0
}

func (m *HostStash) GetUsed() uint64 {
	if m != nil {
		return m.Used
	}
	return 0
}

func (m *HostStash) GetOwner() uint64 {
	if m != nil {
		return m.Owner
	}
	return 0
}

type OpenRequest struct {
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Key  []byte `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
}

func (m *OpenRequest) Reset()                    { *m = OpenRequest{} }
func (m *OpenRequest) String() string            { return proto.CompactTextString(m) }
func (*OpenRequest) ProtoMessage()               {}
func (*OpenRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *OpenRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *OpenRequest) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

type GetBlockRequest struct {
	Key []byte `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
}

func (m *GetBlockRequest) Reset()                    { *m = GetBlockRequest{} }
func (m *GetBlockRequest) String() string            { return proto.CompactTextString(m) }
func (*GetBlockRequest) ProtoMessage()               {}
func (*GetBlockRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *GetBlockRequest) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

type GetBlockResponse struct {
	Data []byte `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *GetBlockResponse) Reset()                    { *m = GetBlockResponse{} }
func (m *GetBlockResponse) String() string            { return proto.CompactTextString(m) }
func (*GetBlockResponse) ProtoMessage()               {}
func (*GetBlockResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *GetBlockResponse) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type AppendToBlockRequest struct {
	BlockSize uint64 `protobuf:"varint,1,opt,name=block_size,json=blockSize" json:"block_size,omitempty"`
	Key       []byte `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	Data      []byte `protobuf:"bytes,3,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *AppendToBlockRequest) Reset()                    { *m = AppendToBlockRequest{} }
func (m *AppendToBlockRequest) String() string            { return proto.CompactTextString(m) }
func (*AppendToBlockRequest) ProtoMessage()               {}
func (*AppendToBlockRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *AppendToBlockRequest) GetBlockSize() uint64 {
	if m != nil {
		return m.BlockSize
	}
	return 0
}

func (m *AppendToBlockRequest) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *AppendToBlockRequest) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type DeleteBlockRequest struct {
	Key []byte `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
}

func (m *DeleteBlockRequest) Reset()                    { *m = DeleteBlockRequest{} }
func (m *DeleteBlockRequest) String() string            { return proto.CompactTextString(m) }
func (*DeleteBlockRequest) ProtoMessage()               {}
func (*DeleteBlockRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *DeleteBlockRequest) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

type WriteResult struct {
	Succeed bool   `protobuf:"varint,1,opt,name=succeed" json:"succeed,omitempty"`
	Remains uint64 `protobuf:"varint,2,opt,name=remains" json:"remains,omitempty"`
	Key     []byte `protobuf:"bytes,3,opt,name=key,proto3" json:"key,omitempty"`
}

func (m *WriteResult) Reset()                    { *m = WriteResult{} }
func (m *WriteResult) String() string            { return proto.CompactTextString(m) }
func (*WriteResult) ProtoMessage()               {}
func (*WriteResult) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *WriteResult) GetSucceed() bool {
	if m != nil {
		return m.Succeed
	}
	return false
}

func (m *WriteResult) GetRemains() uint64 {
	if m != nil {
		return m.Remains
	}
	return 0
}

func (m *WriteResult) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

type NewDirectoryContract struct {
	ParentDir []byte     `protobuf:"bytes,1,opt,name=parent_dir,json=parentDir,proto3" json:"parent_dir,omitempty"`
	Dir       *Directory `protobuf:"bytes,3,opt,name=dir" json:"dir,omitempty"`
}

func (m *NewDirectoryContract) Reset()                    { *m = NewDirectoryContract{} }
func (m *NewDirectoryContract) String() string            { return proto.CompactTextString(m) }
func (*NewDirectoryContract) ProtoMessage()               {}
func (*NewDirectoryContract) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *NewDirectoryContract) GetParentDir() []byte {
	if m != nil {
		return m.ParentDir
	}
	return nil
}

func (m *NewDirectoryContract) GetDir() *Directory {
	if m != nil {
		return m.Dir
	}
	return nil
}

type AcquireFileWriteLockContract struct {
	Key []byte `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
}

func (m *AcquireFileWriteLockContract) Reset()                    { *m = AcquireFileWriteLockContract{} }
func (m *AcquireFileWriteLockContract) String() string            { return proto.CompactTextString(m) }
func (*AcquireFileWriteLockContract) ProtoMessage()               {}
func (*AcquireFileWriteLockContract) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *AcquireFileWriteLockContract) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

type ReleaseFileWriteLockContract struct {
	Key []byte `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
}

func (m *ReleaseFileWriteLockContract) Reset()                    { *m = ReleaseFileWriteLockContract{} }
func (m *ReleaseFileWriteLockContract) String() string            { return proto.CompactTextString(m) }
func (*ReleaseFileWriteLockContract) ProtoMessage()               {}
func (*ReleaseFileWriteLockContract) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *ReleaseFileWriteLockContract) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

type NewFileContract struct {
	Name   string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Dir    []byte `protobuf:"bytes,2,opt,name=dir,proto3" json:"dir,omitempty"`
	Volume []byte `protobuf:"bytes,3,opt,name=volume,proto3" json:"volume,omitempty"`
}

func (m *NewFileContract) Reset()                    { *m = NewFileContract{} }
func (m *NewFileContract) String() string            { return proto.CompactTextString(m) }
func (*NewFileContract) ProtoMessage()               {}
func (*NewFileContract) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *NewFileContract) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *NewFileContract) GetDir() []byte {
	if m != nil {
		return m.Dir
	}
	return nil
}

func (m *NewFileContract) GetVolume() []byte {
	if m != nil {
		return m.Volume
	}
	return nil
}

type FileWriteLock struct {
	Group uint64 `protobuf:"varint,1,opt,name=group" json:"group,omitempty"`
	Owner uint64 `protobuf:"varint,2,opt,name=owner" json:"owner,omitempty"`
	Key   []byte `protobuf:"bytes,4,opt,name=key,proto3" json:"key,omitempty"`
}

func (m *FileWriteLock) Reset()                    { *m = FileWriteLock{} }
func (m *FileWriteLock) String() string            { return proto.CompactTextString(m) }
func (*FileWriteLock) ProtoMessage()               {}
func (*FileWriteLock) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *FileWriteLock) GetGroup() uint64 {
	if m != nil {
		return m.Group
	}
	return 0
}

func (m *FileWriteLock) GetOwner() uint64 {
	if m != nil {
		return m.Owner
	}
	return 0
}

func (m *FileWriteLock) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

type Nothing struct {
}

func (m *Nothing) Reset()                    { *m = Nothing{} }
func (m *Nothing) String() string            { return proto.CompactTextString(m) }
func (*Nothing) ProtoMessage()               {}
func (*Nothing) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func init() {
	proto.RegisterType((*Block)(nil), "client.Block")
	proto.RegisterType((*FileMeta)(nil), "client.FileMeta")
	proto.RegisterType((*Directory)(nil), "client.Directory")
	proto.RegisterType((*Volume)(nil), "client.Volume")
	proto.RegisterType((*HostStash)(nil), "client.HostStash")
	proto.RegisterType((*OpenRequest)(nil), "client.OpenRequest")
	proto.RegisterType((*GetBlockRequest)(nil), "client.GetBlockRequest")
	proto.RegisterType((*GetBlockResponse)(nil), "client.GetBlockResponse")
	proto.RegisterType((*AppendToBlockRequest)(nil), "client.AppendToBlockRequest")
	proto.RegisterType((*DeleteBlockRequest)(nil), "client.DeleteBlockRequest")
	proto.RegisterType((*WriteResult)(nil), "client.WriteResult")
	proto.RegisterType((*NewDirectoryContract)(nil), "client.NewDirectoryContract")
	proto.RegisterType((*AcquireFileWriteLockContract)(nil), "client.AcquireFileWriteLockContract")
	proto.RegisterType((*ReleaseFileWriteLockContract)(nil), "client.ReleaseFileWriteLockContract")
	proto.RegisterType((*NewFileContract)(nil), "client.NewFileContract")
	proto.RegisterType((*FileWriteLock)(nil), "client.FileWriteLock")
	proto.RegisterType((*Nothing)(nil), "client.Nothing")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for PCFS service

type PCFSClient interface {
	GetBlock(ctx context.Context, in *GetBlockRequest, opts ...grpc.CallOption) (*GetBlockResponse, error)
	AppendToBlock(ctx context.Context, in *AppendToBlockRequest, opts ...grpc.CallOption) (*WriteResult, error)
	DeleteBlock(ctx context.Context, in *DeleteBlockRequest, opts ...grpc.CallOption) (*WriteResult, error)
}

type pCFSClient struct {
	cc *grpc.ClientConn
}

func NewPCFSClient(cc *grpc.ClientConn) PCFSClient {
	return &pCFSClient{cc}
}

func (c *pCFSClient) GetBlock(ctx context.Context, in *GetBlockRequest, opts ...grpc.CallOption) (*GetBlockResponse, error) {
	out := new(GetBlockResponse)
	err := grpc.Invoke(ctx, "/client.PCFS/GetBlock", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pCFSClient) AppendToBlock(ctx context.Context, in *AppendToBlockRequest, opts ...grpc.CallOption) (*WriteResult, error) {
	out := new(WriteResult)
	err := grpc.Invoke(ctx, "/client.PCFS/AppendToBlock", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pCFSClient) DeleteBlock(ctx context.Context, in *DeleteBlockRequest, opts ...grpc.CallOption) (*WriteResult, error) {
	out := new(WriteResult)
	err := grpc.Invoke(ctx, "/client.PCFS/DeleteBlock", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for PCFS service

type PCFSServer interface {
	GetBlock(context.Context, *GetBlockRequest) (*GetBlockResponse, error)
	AppendToBlock(context.Context, *AppendToBlockRequest) (*WriteResult, error)
	DeleteBlock(context.Context, *DeleteBlockRequest) (*WriteResult, error)
}

func RegisterPCFSServer(s *grpc.Server, srv PCFSServer) {
	s.RegisterService(&_PCFS_serviceDesc, srv)
}

func _PCFS_GetBlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBlockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PCFSServer).GetBlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/client.PCFS/GetBlock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PCFSServer).GetBlock(ctx, req.(*GetBlockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PCFS_AppendToBlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AppendToBlockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PCFSServer).AppendToBlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/client.PCFS/AppendToBlock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PCFSServer).AppendToBlock(ctx, req.(*AppendToBlockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PCFS_DeleteBlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteBlockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PCFSServer).DeleteBlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/client.PCFS/DeleteBlock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PCFSServer).DeleteBlock(ctx, req.(*DeleteBlockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _PCFS_serviceDesc = grpc.ServiceDesc{
	ServiceName: "client.PCFS",
	HandlerType: (*PCFSServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetBlock",
			Handler:    _PCFS_GetBlock_Handler,
		},
		{
			MethodName: "AppendToBlock",
			Handler:    _PCFS_AppendToBlock_Handler,
		},
		{
			MethodName: "DeleteBlock",
			Handler:    _PCFS_DeleteBlock_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/api.proto",
}

func init() { proto.RegisterFile("proto/api.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 708 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x55, 0xed, 0x4e, 0x13, 0x4d,
	0x14, 0x66, 0xd9, 0xa5, 0xed, 0x9e, 0xb6, 0x81, 0x77, 0x5e, 0x22, 0x6b, 0xc5, 0xa4, 0x59, 0x22,
	0xe9, 0x2f, 0x24, 0x70, 0x01, 0x8a, 0x34, 0xa0, 0x89, 0x80, 0x99, 0x12, 0x4d, 0xf4, 0x47, 0x33,
	0xec, 0x1e, 0xe8, 0xc8, 0x76, 0x67, 0x99, 0x99, 0x4a, 0xf0, 0x1a, 0xbc, 0x37, 0x2f, 0xc4, 0x9b,
	0x30, 0x33, 0xfb, 0xd1, 0x96, 0x42, 0xe4, 0xdf, 0xf9, 0xda, 0xf3, 0xf1, 0x3c, 0xcf, 0x64, 0x61,
	0x35, 0x93, 0x42, 0x8b, 0xd7, 0x2c, 0xe3, 0x3b, 0xd6, 0x22, 0xb5, 0x28, 0xe1, 0x98, 0xea, 0xf0,
	0x10, 0x56, 0xde, 0x25, 0x22, 0xba, 0x26, 0x04, 0xbc, 0x11, 0x53, 0xa3, 0x60, 0xb9, 0xeb, 0xf4,
	0x5a, 0xd4, 0xda, 0x64, 0x0d, 0xdc, 0x6b, 0xbc, 0x0b, 0x5c, 0x1b, 0x32, 0x26, 0x59, 0x87, 0x95,
	0x91, 0x50, 0x5a, 0x05, 0x4e, 0xd7, 0xed, 0x79, 0x34, 0x77, 0xc2, 0x3f, 0x0e, 0x34, 0x8e, 0x78,
	0x82, 0x27, 0xa8, 0x99, 0x69, 0x94, 0xb2, 0x31, 0x06, 0x4e, 0xd7, 0xe9, 0xf9, 0xd4, 0xda, 0x26,
	0xa6, 0xf8, 0x4f, 0xb4, 0xcd, 0x3d, 0x6a, 0x6d, 0xb2, 0x05, 0xed, 0x84, 0x29, 0x3d, 0x3c, 0x11,
	0x31, 0xbf, 0xe4, 0x18, 0xdb, 0x31, 0x1e, 0x6d, 0x99, 0x60, 0x19, 0x23, 0x2f, 0x01, 0x22, 0x89,
	0x4c, 0x63, 0x3c, 0x64, 0x3a, 0xf0, 0x6c, 0x85, 0x5f, 0x44, 0x0e, 0x34, 0x79, 0x01, 0xbe, 0x59,
	0x7e, 0xa8, 0xf9, 0x18, 0x83, 0x15, 0x9b, 0x6d, 0x98, 0xc0, 0x39, 0x1f, 0xa3, 0xf9, 0xf6, 0xc2,
	0x66, 0xed, 0xe8, 0x5a, 0xd7, 0xe9, 0xb5, 0xa9, 0x6f, 0x23, 0x03, 0x33, 0xbf, 0x38, 0xae, 0x3e,
	0x3d, 0xee, 0x15, 0xd4, 0x6c, 0x5a, 0x05, 0x8d, 0xae, 0xdb, 0x6b, 0xee, 0xb5, 0x77, 0x72, 0x90,
	0x76, 0x2c, 0x42, 0xb4, 0x48, 0x86, 0xc7, 0xe0, 0xf7, 0xb9, 0xc4, 0x48, 0x0b, 0x79, 0xf7, 0xe0,
	0xb5, 0x45, 0xe7, 0xe5, 0x39, 0xd8, 0x2e, 0x79, 0x82, 0x2a, 0x70, 0xbb, 0x6e, 0xaf, 0x45, 0x73,
	0x27, 0xfc, 0xe5, 0x40, 0xed, 0xb3, 0x48, 0x26, 0x39, 0x40, 0x4f, 0x68, 0x13, 0x42, 0x4b, 0x62,
	0x96, 0xf0, 0x88, 0x69, 0x2e, 0x52, 0x65, 0x11, 0x6b, 0xd3, 0xb9, 0xd8, 0xbd, 0xab, 0xbd, 0xfb,
	0x57, 0x3f, 0x87, 0x86, 0x14, 0x42, 0x0f, 0x63, 0x2e, 0x2d, 0x60, 0x2d, 0x5a, 0x37, 0x7e, 0x9f,
	0xcb, 0xf0, 0x3b, 0xf8, 0xef, 0x85, 0xd2, 0x03, 0x6d, 0xa8, 0xdf, 0x80, 0xba, 0xe1, 0x76, 0xc8,
	0x63, 0xbb, 0x93, 0x47, 0x6b, 0xc6, 0xfd, 0x10, 0x93, 0x0e, 0x34, 0x22, 0x96, 0xb1, 0x88, 0xeb,
	0xbb, 0x82, 0xce, 0xca, 0x37, 0x57, 0x4c, 0x54, 0xc5, 0xa4, 0xb5, 0xcd, 0xe9, 0xe2, 0x36, 0x45,
	0x59, 0x90, 0x97, 0x3b, 0xe1, 0x3e, 0x34, 0xcf, 0x32, 0x4c, 0x29, 0xde, 0x4c, 0x50, 0xe9, 0xa7,
	0x9d, 0x1f, 0x6e, 0xc1, 0xea, 0x31, 0xea, 0x9c, 0x8c, 0xe2, 0xc3, 0xa2, 0xc8, 0x99, 0x16, 0x6d,
	0xc3, 0xda, 0xb4, 0x48, 0x65, 0x22, 0x55, 0x16, 0xdd, 0x98, 0x69, 0x56, 0x94, 0x59, 0x3b, 0xfc,
	0x06, 0xeb, 0x07, 0x59, 0x86, 0x69, 0x7c, 0x2e, 0xe6, 0x3a, 0xce, 0xe3, 0x97, 0xdf, 0xbe, 0xa8,
	0x9a, 0x19, 0x52, 0xca, 0xe6, 0xee, 0x4c, 0xf3, 0x6d, 0x20, 0x7d, 0x4c, 0x50, 0xe3, 0x3f, 0x96,
	0x1d, 0x40, 0xf3, 0x8b, 0xe4, 0x1a, 0x29, 0xaa, 0x49, 0xa2, 0x49, 0x00, 0x75, 0x35, 0x89, 0x22,
	0xc4, 0x1c, 0xf4, 0x06, 0x2d, 0x5d, 0x93, 0x91, 0x38, 0x66, 0x3c, 0x55, 0x05, 0xe8, 0xa5, 0xbb,
	0xf8, 0x46, 0xc3, 0xaf, 0xb0, 0x7e, 0x8a, 0xb7, 0x95, 0x44, 0x0f, 0x45, 0xaa, 0x25, 0x8b, 0xec,
	0x65, 0x19, 0x93, 0x98, 0xe6, 0xe4, 0xe7, 0x5b, 0xf8, 0x79, 0xa4, 0xcf, 0x25, 0xd9, 0x02, 0xd7,
	0xc4, 0x4d, 0xa3, 0xe6, 0xde, 0x7f, 0xa5, 0xf4, 0xab, 0x36, 0xd4, 0x64, 0xc3, 0x5d, 0xd8, 0x3c,
	0x88, 0x6e, 0x26, 0x5c, 0xa2, 0x79, 0xef, 0x76, 0xf7, 0x8f, 0x22, 0xba, 0xae, 0x66, 0x2c, 0x9e,
	0xb8, 0x0b, 0x9b, 0x14, 0x13, 0x64, 0xea, 0xc9, 0x5f, 0x9c, 0xc1, 0xea, 0x29, 0xde, 0x9a, 0xea,
	0xaa, 0xe8, 0x11, 0x7d, 0x98, 0x7d, 0x0b, 0x26, 0x62, 0x2e, 0xc9, 0x33, 0xa8, 0xfd, 0xb0, 0xcf,
	0xa9, 0x40, 0xa3, 0xf0, 0xc2, 0x13, 0x68, 0xcf, 0xcd, 0x36, 0x9a, 0xbc, 0x92, 0x62, 0x92, 0x15,
	0xf4, 0xe6, 0xce, 0x54, 0xa9, 0xcb, 0x33, 0x4a, 0x2d, 0xf7, 0xf3, 0xa6, 0xfb, 0xf9, 0x50, 0x3f,
	0x15, 0x7a, 0xc4, 0xd3, 0xab, 0xbd, 0xdf, 0x0e, 0x78, 0x9f, 0x0e, 0x8f, 0x06, 0xe4, 0x0d, 0x34,
	0x4a, 0xd5, 0x91, 0x8d, 0x12, 0xbb, 0x7b, 0x62, 0xed, 0x04, 0x8b, 0x89, 0x5c, 0xa0, 0xe1, 0x12,
	0xe9, 0x43, 0x7b, 0x4e, 0x8e, 0x64, 0xb3, 0x2c, 0x7e, 0x48, 0xa5, 0x9d, 0xff, 0xcb, 0xec, 0x8c,
	0x7c, 0xc2, 0x25, 0xf2, 0x16, 0x9a, 0x33, 0xba, 0x23, 0x9d, 0x8a, 0xc5, 0x05, 0x31, 0x3e, 0xd2,
	0xe1, 0xa2, 0x66, 0x7f, 0x0f, 0xfb, 0x7f, 0x03, 0x00, 0x00, 0xff, 0xff, 0xb5, 0xb9, 0x8b, 0x03,
	0x31, 0x06, 0x00, 0x00,
}
